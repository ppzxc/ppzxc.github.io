---
type: post
date: 2018-04-11 14:20:09
title: 2018-04-11 독서 일지
draft: false
author: ppzxc
tags:
  - 일지
---

# 들어가며

- 습관을 들이기 위해 하루 하루 일지를 작성할 예정

# Code, 하드웨어와 소프트웨어에 숨어 있는 언어 [찰스 펫졸드]

## 이진 덧셈기

## 이진 뺄셈..

- 와우 순식간이네... 가산기까지... 완벽하게 숙지가 되지는 않지만, 뺄셈을 덧셈만으로 구하는 방법, 덧셈기의 원리 등등 기본내용이 나온다.
- 보수가 필요한 이유, 보수는 인버터로 구현이 가능한점 등
- 전체적으로 모든게 흡수가 되는 느낌은 아니다. 나중에 다시 읽어봐야 겠다.

> 음... 일반적인 int 변수의 범위가 -부터 0 +양수 까지 범위가 제한된 이유가 나온다.
> unsigned int는 음수를 표현하는 플래그 비트를 음수로 사용하지 않을때 2배로 큰 양수 범위를 사용할 수 있는 이유가 여기에서 설명된다.
> 숫자가 원형으로 늘어진 형태는.. [링크](https://jungha-cho.github.io/2017/04/03/2complement/) 참고

- 8비트 메모리를 가지는 정수는 -128~127 까지 범위를 가지는데 이게 비트 형태일때 계속 비트를 1로 더하면 127 다음에 숫자는 -128이다.
- 이걸 숫자가 원형으로 표현되어 있다고 얘기하는 것이다.

> 모든 뺄셈은 덧셈으로 계산할 수 있다.
> 143원을 가지고 있다고 하자. 여기에서 78을 빼려면, 143 + (-78) 이다. 바꿔서 -78을 10의 보수로 표현하면 **_999 - 078 +1_** 이므로 **_922_** 가 된다.
> 따라서 원래 계산식은 143+922로 표현 가능하다. 이 계산은 자리 올림을 무시할 것임으로 65원이 된다.
> 또 나아가서 150을 또 빼면, 앞에 설명한 계산식으로 150의 10이 보수는 850이되며, **_065+850_** 인데, 이는 **_915_** 원이고 실제적으로 음수 값 `-85`를 의미한다. (음수를 표현하는 제일 첫번째 비트가 1로 켜져 있으므로..)

# 테스트 주도 개발로 배우는 객체 지향 설계와 실천 [스티브 프리먼, 냇 프라이스]

## 동작하는 골격

- 동작하는 골격의 핵심은 대략적인 시스템 구조를 제안하고 그것의 유효성을 검증할 수 있을 정도로 요구 사항을 이해하는데 이바지 하는 것이다.

- 참으로 맞는 말만 하시는 분이네.....
- 어떤 시스템의 대략적인 구조 뿐만 아니라, 개발에서 빌드 환경, 운영 환경까지 배포 가능한 구조를 잡고 세팅하는 과정에서 온갖 기술적인 문제가 튀어 나온다.
- 여기서 골격이라 함은 실 비즈니스 로직이나, 실제적인 요구사항을 테스트 해볼수 있고 개발 할 수 있으며, 배포 할수 있는 기반 환경이고 이를 `골격`이라고 표현하는것 같다.

## 첫 테스트 통과하기

## 입찰 준비

# 실용주의 프로그래머 [앤드류 헌트, 데이비드 토머스]

## 코딩하는 동안 해야 할 일들

> 우연에 맡기는 프로그래밍 != 추측하지 말고 검증하라.

- 예전, 어느 커뮤니티에서 이런 글을 봤다. 어느 남자가 의자 옆에 털썩 앉아 좌절 하는 사진과 함께 글이 있었는데, 글 내용은 `프로그램이 돌아가는데 왜 돌아가는지 모르겠어.` 였다. 이 예시가 말하듯, 우연에 맡기는 것은 왜 그렇게 동작하는지 설명하지 못하는 선 무당이 되기 쉽다.

## 우연에 맡기는 프로그래밍

> 의도적으로 프로그래밍하라

- 잘 돌아 간다고 `생각`만 한적이 몇번이던가..... 눈, 손, 감 코딩을 하면서 간단하고 제한적인 테스트 케이스를 통해 잘 돌아간다고 `확신`을 갖게 되니 그 코드는 눈덩이가 되어 나한테 돌아 왔었다.
- 내가 짠 코드 뿐만 아니라 남의 코드 또한 살펴보고 수정 보완해야 하는 업무가 있었는데, 정말로 극한 직업이 따로 없었다....
- 실 업무에서도 느꼈던 내용인 만큼 이 챕터에서는 참고할만한 격언이 많이 나온다.

> 우연에 맡기지 말고 운에 맡기지 말라는 말은 실제로 테스트 케이스를 세워가며 검증하고 그 기반으로 코드를 작성해 나가라는 말인데, 이는 `추측하지 말고 검증하라` 라는 말과 일맥 상통 한다.

- 계획을 세우라, 언제나 자기 자신이 무엇을 하고 있는지 자각해야 하며, 맹목적이지 말라.
- 신뢰할 수 있는 것에만 기대고, 우연한 일이나, 가정에 기대지 말라.
- 나만의 가정은 혼자 생각하지 말고, 문서로 남겨라.

## 알고리즘의 속도

- 반복문이나 재귀 호출 코드를 작성할때, 무리한 일을 하는 것은 아닌지 항상 새각해 보고, O() 표기법으로 정식 계산 또한 진행하라

| 구분       | 내용                                                                             |
| ---------- | -------------------------------------------------------------------------------- |
| O(1)       | 상수적 ( 배열 원소 접근, 단순 명령문)                                            |
| O(log(n))  | 대수적 (이진 검색)                                                               |
| O(n)       | 선형적 (순차 검색)                                                               |
| O(nlog(n)) | 선형보다는 좋지 않지만, 많이 나쁘진 않음 (heap 정렬, quick 정렬의 평균 수행시간) |
| O(n^2)     | 제곱 (선택 정렬, 삽입 정렬)                                                      |
| O(n^3)     | 세제곱 2차원 배열 2개의 곱                                                       |
| O(C^n)     | 지수적 (여행하는 판매원 문제, 집합 분할)                                         |

## 2중 반복문

- 요즘 알고리즘 공부를 하면서 정렬이나 기초적인 자료구조를 구현할 문제를 발견해서 코딩하고 있는데, 관련 내용이 나왔다. 간단한 정렬이란, 버블, 삽입, 선택 정렬 처럼 2중 반복문을 포함하는 정렬을 얘기한다.
- 또 이러한 정렬은 바깥쪽 반복문이 배열을 순서대로 순회하는데 이를 `round`라 표현하고, 안쪽 반복문은 각 라운드 내에서 최대값이나 최소 값을 찾는다.

## 반씩 잘라내기

- 하나의 반복문에서 검색 대상의 범위를 반틈씩 제거해 나간다면 `O(log(n))`이 될 가능성이 있다. 정렬 목록의 이진 검색이나, 이진 트리의 순회 등이 이에 해당한다.

## DIVIDE AND CONQUER

- 데이터를 반으로 나눠 각각 독립적으로 작업한 다음 결과를 합친다면, `O(nlog(n))`일 확률이 높다. 이미 정렬된 값이 들어올 경우 성능이 떨어지기 때문에, O(n^2)이 될 수도 있지만, 퀵정렬의 평균 수행 시간은 O(nlog(n))이다.

> 현실이다. 이제 이 기본적인 정렬이나 자료구조 구현에 실 업무의 아까운 시간을 투자하진 않는다. 나 또한 그렇다. Java가 제공하는 라이브러리를 이용하고, 이미 구현 되어 있는 것을 사용한다. 다만, 이 책에서는 이를 제외하고, 일반적으로 코드를 작성할때 사용하는 반복문이나, while 루프, 이중 반복문 또는 어떤 알고리즘 등 그 코드를 수행하는데 얼마나 걸릴지, 얼마나 큰 수의 입력이 들어올지 예상하고 작성하라는 것이다.

## 테스트 하기 쉬운 코드

# Reference

- 찰스 펫졸드, 『 Code, 하드웨어와 소프트웨어에 숨어있는 언어 』, 인사이트(2010 10 11), 인용.
- 스티브 프리먼, 냇 프라이스 지음, 이대엽 옮김, 『 테스트 주도 개발로 배우는 객체 지향 설계와 실천 』, 인사이트(2013 06 20), 인용.
- 앤드류 헌트, 데이비드 토머스 지음, 김창준, 정지호 옮김, 『 실용주의 프로그래머 』, 인사이트(2005 08 02), 인용.
